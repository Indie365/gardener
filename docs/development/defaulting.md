# Defaulting Strategy and Developer Guideline

This document walks you through:

- Conventioned to be followed when writing defaulting functions
- How to write test for defaulting function

The document is aimed towards developers that want to contribute code and need to write defaulting code and unit tests covering the defaulting functions, as well as maintainers and reviewers that review code.
It serves as a common guide that we commit to follow in our project to ensure consistency in our defaulting code, good coverage for high confidence, and good maintainability.

## Writing defaulting code

- Every Kubernetes type should have a dedicated `defaults_*.go` file. For instance, if you have a `Shoot` type, there should be a corresponding `defaults_shoot.go` file containing all defaulting logic for that type.
- If there is only one type under an api group then we can just have `types.go` and a corresponding `defaults.go` file.
- Aim to segregate each struct type into its own `SetDefaults_*` function. These functions encapsulate the defaulting logic specific to the corresponding struct type, enhancing modularity and maintainability.

:warning: Ensure to run the `make generate` command, which generates the `zz_generated.defaults.go` file containing the overall defaulting function.

## Writing unit tests for defaulting code

- Each test case should validate the overall defaulting function `SetObjectDefaults_*` generated by `defaulter-gen` and not a specific `SetDefaults_*`. This way we also test if the `zz_generated.defaults.go` was generated correctly.
- Test each defaulting function carefully to ensure:
    - Proper defaulting behaviour when fields are empty or nil. Note that some fields may be optional and should not be defaulted.
    - Preservation of existing values, ensuring that defaulting does not accidentally overwrite them.